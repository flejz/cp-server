package store

import (
	"database/sql"
	"fmt"
	"strings"
)

type StoreInterface interface {
	Init() error
	Query(selectFields []string, whereMap map[string]interface{}) (*sql.Rows, error)
}

func Init(stores []StoreInterface) error {
	for _, store := range stores {
		if err := store.Init(); err != nil {
			return err
		}
	}

	return nil
}

type BaseStore struct {
	DB       *sql.DB
	Table    string
	FieldMap map[string]string
}

func (store *BaseStore) Init() error {
	fieldList := []string{}
	for field, fieldType := range store.FieldMap {
		fieldList = append(fieldList, fmt.Sprintf("%s %s", field, fieldType))
	}

	fields := strings.Join(fieldList, ",")
	cmd := fmt.Sprintf("CREATE TABLE IF NOT EXISTS %s (%s)", store.Table, fields)

	if _, err := store.DB.Exec(cmd); err != nil {
		return err
	}
	return nil
}

func (store *BaseStore) Query(selectFields []string, whereMap map[string]interface{}) (*sql.Rows, error) {
	args := []interface{}{}

	fields := strings.Join(selectFields, ",")
	whereList := []string{}

	for field, value := range whereMap {
		whereList = append(whereList, fmt.Sprintf("%s = ?", field))
		args = append(args, value)
	}

	where := strings.Join(whereList, " AND ")
	query := fmt.Sprintf("SELECT %s FROM %s WHERE %s", fields, store.Table, where)
	return store.DB.Query(query, args...)
}

func (store *BaseStore) Insert(fieldMap map[string]interface{}) error {
	args := []interface{}{}
	fields := []string{}
	for field, value := fieldMap {

	}

	qmarks := store.spread(len(fields), ",")
	cmd := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s)", store.Table, fields, qmarks)

	statement, err := store.DB.Prepare(cmd)
	if err != nil {
		return err
	}

	_, err = statement.Exec(usr, key, value)
	return err
}
